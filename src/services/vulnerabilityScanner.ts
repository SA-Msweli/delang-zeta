/**
 * Automated Vulnerability Scanner
 * Client-side security scanning and vulnerability detection
 */

import { SecurityMonitoringService, SecurityEventType, SecuritySeverity } from './securityMonitoring'

export interface VulnerabilityReport {
  id: string
  timestamp: string
  scanType: ScanType
  vulnerabilities: Vulnerability[]
  riskScore: number
  recommendations: string[]
  scanDuration: number
}

export interface Vulnerability {
  id: string
  type: VulnerabilityType
  severity: SecuritySeverity
  title: string
  description: string
  location: string
  evidence: Record<string, any>
  remediation: string
  cwe?: string // Common Weakness Enumeration
  cvss?: number // Common Vulnerability Scoring System
}

export enum ScanType {
  FULL_SCAN = 'full',
  QUICK_SCAN = 'quick',
  TARGETED_SCAN = 'targeted',
  CONTINUOUS_SCAN = 'continuous'
}

export enum VulnerabilityType {
  XSS = 'xss',
  CSRF = 'csrf',
  INSECURE_STORAGE = 'insecure_storage',
  WEAK_AUTHENTICATION = 'weak_auth',
  INFORMATION_DISCLOSURE = 'info_disclosure',
  INSECURE_COMMUNICATION = 'insecure_comm',
  CLIENT_SIDE_INJECTION = 'client_injection',
  WEAK_CRYPTOGRAPHY = 'weak_crypto',
  INSECURE_CONFIGURATION = 'insecure_config',
  DEPENDENCY_VULNERABILITY = 'dependency_vuln',
  PRIVACY_VIOLATION = 'privacy_violation',
  ACCESS_CONTROL = 'access_control'
}

export class VulnerabilityScanner {
  private static readonly REPORTS_KEY = 'delang_vuln_reports'
  private static readonly MAX_REPORTS = 50
  private static reports: VulnerabilityReport[] = []
  private static scanning = false

  /**
   * Initialize vulnerability scanner
   */
  static initialize(): void {
    this.loadReports()

    // Run initial quick scan
    setTimeout(() => {
      this.runQuickScan()
    }, 5000)

    // Schedule periodic scans
    setInterval(() => {
      this.runContinuousScan()
    }, 30 * 60 * 1000) // Every 30 minutes
  }

  /**
   * Run full vulnerability scan
   */
  static async runFullScan(): Promise<VulnerabilityReport> {
    if (this.scanning) {
      throw new Error('Scan already in progress')
    }

    this.scanning = true
    const startTime = Date.now()
    const vulnerabilities: Vulnerability[] = []

    try {
      // Run all scan modules
      vulnerabilities.push(...await this.scanForXSS())
      vulnerabilities.push(...await this.scanForCSRF())
      vulnerabilities.push(...await this.scanForInsecureStorage())
      vulnerabilities.push(...await this.scanForWeakAuthentication())
      vulnerabilities.push(...await this.scanForInformationDisclosure())
      vulnerabilities.push(...await this.scanForInsecureCommunication())
      vulnerabilities.push(...await this.scanForClientSideInjection())
      vulnerabilities.push(...await this.scanForWeakCryptography())
      vulnerabilities.push(...await this.scanForInsecureConfiguration())
      vulnerabilities.push(...await this.scanForDependencyVulnerabilities())
      vulnerabilities.push(...await this.scanForPrivacyViolations())
      vulnerabilities.push(...await this.scanForAccessControl())

      const report = this.generateReport(ScanType.FULL_SCAN, vulnerabilities, Date.now() - startTime)
      this.saveReport(report)

      SecurityMonitoringService.logEvent(
        SecurityEventType.VULNERABILITY_SCAN,
        {
          scanType: ScanType.FULL_SCAN,
          vulnerabilitiesFound: vulnerabilities.length,
          riskScore: report.riskScore
        },
        vulnerabilities.length > 0 ? SecuritySeverity.MEDIUM : SecuritySeverity.LOW
      )

      return report
    } finally {
      this.scanning = false
    }
  }

  /**
   * Run quick vulnerability scan
   */
  static async runQuickScan(): Promise<VulnerabilityReport> {
    const startTime = Date.now()
    const vulnerabilities: Vulnerability[] = []

    // Run essential checks only
    vulnerabilities.push(...await this.scanForXSS())
    vulnerabilities.push(...await this.scanForInsecureStorage())
    vulnerabilities.push(...await this.scanForWeakAuthentication())
    vulnerabilities.push(...await this.scanForInsecureCommunication())

    const report = this.generateReport(ScanType.QUICK_SCAN, vulnerabilities, Date.now() - startTime)
    this.saveReport(report)

    return report
  }

  /**
   * Run continuous monitoring scan
   */
  static async runContinuousScan(): Promise<void> {
    const vulnerabilities: Vulnerability[] = []

    // Monitor for runtime vulnerabilities
    vulnerabilities.push(...await this.scanForClientSideInjection())
    vulnerabilities.push(...await this.scanForInsecureConfiguration())

    if (vulnerabilities.length > 0) {
      const report = this.generateReport(ScanType.CONTINUOUS_SCAN, vulnerabilities, 0)
      this.saveReport(report)

      SecurityMonitoringService.logEvent(
        SecurityEventType.VULNERABILITY_SCAN,
        {
          scanType: ScanType.CONTINUOUS_SCAN,
          vulnerabilitiesFound: vulnerabilities.length
        },
        SecuritySeverity.MEDIUM
      )
    }
  }

  /**
   * Scan for XSS vulnerabilities
   */
  private static async scanForXSS(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for dangerous innerHTML usage
    const scripts = document.querySelectorAll('script')
    scripts.forEach((script, index) => {
      if (script.innerHTML.includes('innerHTML') && script.innerHTML.includes('user')) {
        vulnerabilities.push({
          id: `xss_${index}`,
          type: VulnerabilityType.XSS,
          severity: SecuritySeverity.HIGH,
          title: 'Potential XSS via innerHTML',
          description: 'Script contains innerHTML usage that may be vulnerable to XSS',
          location: `Script tag ${index}`,
          evidence: { scriptContent: script.innerHTML.substring(0, 200) },
          remediation: 'Use textContent instead of innerHTML or sanitize input',
          cwe: 'CWE-79',
          cvss: 7.5
        })
      }
    })

    // Check for eval usage
    const pageSource = document.documentElement.outerHTML
    if (pageSource.includes('eval(') || pageSource.includes('Function(')) {
      vulnerabilities.push({
        id: 'xss_eval',
        type: VulnerabilityType.XSS,
        severity: SecuritySeverity.CRITICAL,
        title: 'Dangerous eval() usage detected',
        description: 'Use of eval() or Function() constructor can lead to code injection',
        location: 'Page source',
        evidence: { hasEval: true },
        remediation: 'Remove eval() usage and use safer alternatives',
        cwe: 'CWE-95',
        cvss: 9.0
      })
    }

    return vulnerabilities
  }

  /**
   * Scan for CSRF vulnerabilities
   */
  private static async scanForCSRF(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for CSRF token presence
    const csrfToken = sessionStorage.getItem('delang_csrf_token')
    if (!csrfToken) {
      vulnerabilities.push({
        id: 'csrf_no_token',
        type: VulnerabilityType.CSRF,
        severity: SecuritySeverity.MEDIUM,
        title: 'Missing CSRF token',
        description: 'No CSRF token found in session storage',
        location: 'Session storage',
        evidence: { csrfTokenPresent: false },
        remediation: 'Implement CSRF token generation and validation',
        cwe: 'CWE-352',
        cvss: 6.5
      })
    }

    // Check forms for CSRF protection
    const forms = document.querySelectorAll('form')
    forms.forEach((form, index) => {
      const hasCSRFField = form.querySelector('input[name*="csrf"], input[name*="token"]')
      if (!hasCSRFField && form.method?.toLowerCase() === 'post') {
        vulnerabilities.push({
          id: `csrf_form_${index}`,
          type: VulnerabilityType.CSRF,
          severity: SecuritySeverity.MEDIUM,
          title: 'Form missing CSRF protection',
          description: 'POST form does not include CSRF token field',
          location: `Form ${index}`,
          evidence: { formAction: form.action, formMethod: form.method },
          remediation: 'Add CSRF token field to all POST forms',
          cwe: 'CWE-352',
          cvss: 6.0
        })
      }
    })

    return vulnerabilities
  }

  /**
   * Scan for insecure storage vulnerabilities
   */
  private static async scanForInsecureStorage(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for sensitive data in localStorage
    const sensitiveKeys = ['password', 'secret', 'key', 'token', 'private']
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i)
      if (key && sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {
        const value = localStorage.getItem(key)
        if (value && value.length > 10) {
          vulnerabilities.push({
            id: `storage_${key}`,
            type: VulnerabilityType.INSECURE_STORAGE,
            severity: SecuritySeverity.HIGH,
            title: 'Sensitive data in localStorage',
            description: `Potentially sensitive data stored in localStorage: ${key}`,
            location: 'localStorage',
            evidence: { key, valueLength: value.length },
            remediation: 'Use secure storage mechanisms or encrypt sensitive data',
            cwe: 'CWE-312',
            cvss: 7.0
          })
        }
      }
    }

    // Check for unencrypted tokens
    const accessToken = localStorage.getItem('access_token')
    if (accessToken && !accessToken.startsWith('ey')) { // JWT tokens start with 'ey'
      vulnerabilities.push({
        id: 'storage_unencrypted_token',
        type: VulnerabilityType.INSECURE_STORAGE,
        severity: SecuritySeverity.HIGH,
        title: 'Unencrypted access token',
        description: 'Access token appears to be stored in plain text',
        location: 'localStorage',
        evidence: { tokenFormat: 'plain_text' },
        remediation: 'Use encrypted tokens or secure token storage',
        cwe: 'CWE-312',
        cvss: 7.5
      })
    }

    return vulnerabilities
  }

  /**
   * Scan for weak authentication vulnerabilities
   */
  private static async scanForWeakAuthentication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for weak password requirements
    const passwordInputs = document.querySelectorAll('input[type="password"]')
    passwordInputs.forEach((input, index) => {
      const minLength = input.getAttribute('minlength')
      if (!minLength || parseInt(minLength) < 8) {
        vulnerabilities.push({
          id: `auth_weak_password_${index}`,
          type: VulnerabilityType.WEAK_AUTHENTICATION,
          severity: SecuritySeverity.MEDIUM,
          title: 'Weak password requirements',
          description: 'Password field has insufficient minimum length requirement',
          location: `Password input ${index}`,
          evidence: { minLength: minLength || 'none' },
          remediation: 'Enforce minimum password length of 8+ characters',
          cwe: 'CWE-521',
          cvss: 5.5
        })
      }
    })

    // Check for missing two-factor authentication
    const has2FA = document.querySelector('[data-testid*="2fa"], [class*="two-factor"], [id*="mfa"]')
    if (!has2FA) {
      vulnerabilities.push({
        id: 'auth_no_2fa',
        type: VulnerabilityType.WEAK_AUTHENTICATION,
        severity: SecuritySeverity.MEDIUM,
        title: 'Missing two-factor authentication',
        description: 'No evidence of two-factor authentication implementation',
        location: 'Authentication system',
        evidence: { has2FA: false },
        remediation: 'Implement two-factor authentication for enhanced security',
        cwe: 'CWE-308',
        cvss: 6.0
      })
    }

    return vulnerabilities
  }

  /**
   * Scan for information disclosure vulnerabilities
   */
  private static async scanForInformationDisclosure(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for debug information in console
    const originalConsoleError = console.error
    let errorCount = 0
    console.error = (...args) => {
      errorCount++
      return originalConsoleError(...args)
    }

    // Check for exposed API keys or secrets in page source
    const pageSource = document.documentElement.outerHTML
    const secretPatterns = [
      /sk_[a-zA-Z0-9]{24,}/g, // Stripe secret keys
      /pk_[a-zA-Z0-9]{24,}/g, // Stripe public keys
      /AIza[0-9A-Za-z\\-_]{35}/g, // Google API keys
      /[0-9a-fA-F]{32}/g, // Generic 32-char hex strings
    ]

    secretPatterns.forEach((pattern, index) => {
      const matches = pageSource.match(pattern)
      if (matches) {
        vulnerabilities.push({
          id: `info_disclosure_${index}`,
          type: VulnerabilityType.INFORMATION_DISCLOSURE,
          severity: SecuritySeverity.CRITICAL,
          title: 'Exposed API key or secret',
          description: 'Potential API key or secret found in page source',
          location: 'Page source',
          evidence: { pattern: pattern.toString(), matchCount: matches.length },
          remediation: 'Remove secrets from client-side code and use environment variables',
          cwe: 'CWE-200',
          cvss: 9.0
        })
      }
    })

    return vulnerabilities
  }

  /**
   * Scan for insecure communication vulnerabilities
   */
  private static async scanForInsecureCommunication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check if site is served over HTTPS
    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
      vulnerabilities.push({
        id: 'comm_no_https',
        type: VulnerabilityType.INSECURE_COMMUNICATION,
        severity: SecuritySeverity.HIGH,
        title: 'Site not served over HTTPS',
        description: 'Application is not using HTTPS encryption',
        location: 'Protocol',
        evidence: { protocol: window.location.protocol },
        remediation: 'Enable HTTPS for all communications',
        cwe: 'CWE-319',
        cvss: 7.5
      })
    }

    // Check for mixed content
    const images = document.querySelectorAll('img[src^="http:"]')
    const scripts = document.querySelectorAll('script[src^="http:"]')
    const links = document.querySelectorAll('link[href^="http:"]')

    if (images.length > 0 || scripts.length > 0 || links.length > 0) {
      vulnerabilities.push({
        id: 'comm_mixed_content',
        type: VulnerabilityType.INSECURE_COMMUNICATION,
        severity: SecuritySeverity.MEDIUM,
        title: 'Mixed content detected',
        description: 'HTTP resources loaded on HTTPS page',
        location: 'Page resources',
        evidence: {
          httpImages: images.length,
          httpScripts: scripts.length,
          httpLinks: links.length
        },
        remediation: 'Use HTTPS for all external resources',
        cwe: 'CWE-319',
        cvss: 6.0
      })
    }

    return vulnerabilities
  }

  /**
   * Scan for client-side injection vulnerabilities
   */
  private static async scanForClientSideInjection(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Monitor for dynamic script creation
    const originalCreateElement = document.createElement
    document.createElement = function (tagName: string) {
      const element = originalCreateElement.call(this, tagName)
      if (tagName.toLowerCase() === 'script') {
        vulnerabilities.push({
          id: `injection_dynamic_script_${Date.now()}`,
          type: VulnerabilityType.CLIENT_SIDE_INJECTION,
          severity: SecuritySeverity.HIGH,
          title: 'Dynamic script creation detected',
          description: 'Script element created dynamically at runtime',
          location: 'Runtime',
          evidence: { timestamp: Date.now() },
          remediation: 'Avoid dynamic script creation or validate sources',
          cwe: 'CWE-79',
          cvss: 7.0
        })
      }
      return element
    }

    return vulnerabilities
  }

  /**
   * Scan for weak cryptography vulnerabilities
   */
  private static async scanForWeakCryptography(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for weak random number generation
    const originalMathRandom = Math.random
    let weakRandomUsage = 0
    Math.random = function () {
      weakRandomUsage++
      return originalMathRandom()
    }

    // Check after a short delay
    setTimeout(() => {
      if (weakRandomUsage > 0) {
        vulnerabilities.push({
          id: 'crypto_weak_random',
          type: VulnerabilityType.WEAK_CRYPTOGRAPHY,
          severity: SecuritySeverity.MEDIUM,
          title: 'Weak random number generation',
          description: 'Math.random() used instead of cryptographically secure random',
          location: 'JavaScript code',
          evidence: { usageCount: weakRandomUsage },
          remediation: 'Use crypto.getRandomValues() for cryptographic purposes',
          cwe: 'CWE-338',
          cvss: 5.5
        })
      }
    }, 1000)

    return vulnerabilities
  }

  /**
   * Scan for insecure configuration vulnerabilities
   */
  private static async scanForInsecureConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for debug mode indicators
    if (process.env.NODE_ENV === 'development' && window.location.hostname !== 'localhost') {
      vulnerabilities.push({
        id: 'config_debug_mode',
        type: VulnerabilityType.INSECURE_CONFIGURATION,
        severity: SecuritySeverity.HIGH,
        title: 'Debug mode enabled in production',
        description: 'Application appears to be running in debug mode',
        location: 'Environment configuration',
        evidence: { nodeEnv: process.env.NODE_ENV },
        remediation: 'Disable debug mode in production environments',
        cwe: 'CWE-489',
        cvss: 7.0
      })
    }

    // Check for missing security headers
    const securityHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security'
    ]

    // This would typically be checked server-side, but we can check if they're set via meta tags
    securityHeaders.forEach(header => {
      const metaTag = document.querySelector(`meta[http-equiv="${header}"]`)
      if (!metaTag) {
        vulnerabilities.push({
          id: `config_missing_header_${header.toLowerCase()}`,
          type: VulnerabilityType.INSECURE_CONFIGURATION,
          severity: SecuritySeverity.MEDIUM,
          title: `Missing security header: ${header}`,
          description: `Security header ${header} is not configured`,
          location: 'HTTP headers',
          evidence: { missingHeader: header },
          remediation: `Configure ${header} security header`,
          cwe: 'CWE-16',
          cvss: 5.0
        })
      }
    })

    return vulnerabilities
  }

  /**
   * Scan for dependency vulnerabilities
   */
  private static async scanForDependencyVulnerabilities(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for known vulnerable libraries (simplified check)
    const scripts = document.querySelectorAll('script[src]')
    const knownVulnerablePatterns = [
      { pattern: /jquery.*1\.[0-8]/, name: 'jQuery', issue: 'XSS vulnerabilities in older versions' },
      { pattern: /lodash.*[0-3]\./, name: 'Lodash', issue: 'Prototype pollution vulnerabilities' },
      { pattern: /moment.*2\.[0-9]\./, name: 'Moment.js', issue: 'ReDoS vulnerabilities' }
    ]

    scripts.forEach((script, index) => {
      const src = script.getAttribute('src')
      if (src) {
        knownVulnerablePatterns.forEach(vuln => {
          if (vuln.pattern.test(src)) {
            vulnerabilities.push({
              id: `dep_vuln_${index}`,
              type: VulnerabilityType.DEPENDENCY_VULNERABILITY,
              severity: SecuritySeverity.HIGH,
              title: `Vulnerable dependency: ${vuln.name}`,
              description: vuln.issue,
              location: `Script: ${src}`,
              evidence: { src, library: vuln.name },
              remediation: `Update ${vuln.name} to latest secure version`,
              cwe: 'CWE-1104',
              cvss: 7.5
            })
          }
        })
      }
    })

    return vulnerabilities
  }

  /**
   * Scan for privacy violations
   */
  private static async scanForPrivacyViolations(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for tracking scripts without consent
    const trackingDomains = ['google-analytics.com', 'googletagmanager.com', 'facebook.net']
    const scripts = document.querySelectorAll('script[src]')

    scripts.forEach((script, index) => {
      const src = script.getAttribute('src')
      if (src && trackingDomains.some(domain => src.includes(domain))) {
        // Check if there's a consent mechanism
        const consentElements = document.querySelectorAll('[class*="consent"], [id*="consent"], [class*="cookie"], [id*="cookie"]')
        if (consentElements.length === 0) {
          vulnerabilities.push({
            id: `privacy_tracking_${index}`,
            type: VulnerabilityType.PRIVACY_VIOLATION,
            severity: SecuritySeverity.MEDIUM,
            title: 'Tracking without consent',
            description: 'Tracking scripts loaded without apparent user consent mechanism',
            location: `Script: ${src}`,
            evidence: { src, consentMechanism: false },
            remediation: 'Implement proper consent management for tracking',
            cwe: 'CWE-359',
            cvss: 5.0
          })
        }
      }
    })

    return vulnerabilities
  }

  /**
   * Scan for access control vulnerabilities
   */
  private static async scanForAccessControl(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = []

    // Check for client-side access control
    const adminElements = document.querySelectorAll('[class*="admin"], [id*="admin"], [data-role="admin"]')
    if (adminElements.length > 0) {
      vulnerabilities.push({
        id: 'access_client_side_control',
        type: VulnerabilityType.ACCESS_CONTROL,
        severity: SecuritySeverity.HIGH,
        title: 'Client-side access control detected',
        description: 'Access control appears to be implemented client-side only',
        location: 'DOM elements',
        evidence: { adminElementCount: adminElements.length },
        remediation: 'Implement server-side access control validation',
        cwe: 'CWE-602',
        cvss: 7.0
      })
    }

    return vulnerabilities
  }

  /**
   * Generate vulnerability report
   */
  private static generateReport(
    scanType: ScanType,
    vulnerabilities: Vulnerability[],
    scanDuration: number
  ): VulnerabilityReport {
    // Calculate risk score
    const riskScore = vulnerabilities.reduce((score, vuln) => {
      switch (vuln.severity) {
        case SecuritySeverity.CRITICAL: return score + 25
        case SecuritySeverity.HIGH: return score + 15
        case SecuritySeverity.MEDIUM: return score + 8
        case SecuritySeverity.LOW: return score + 3
        default: return score
      }
    }, 0)

    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerabilities)

    return {
      id: `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      scanType,
      vulnerabilities,
      riskScore: Math.min(100, riskScore),
      recommendations,
      scanDuration
    }
  }

  /**
   * Generate security recommendations
   */
  private static generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = []
    const vulnTypes = new Set(vulnerabilities.map(v => v.type))

    if (vulnTypes.has(VulnerabilityType.XSS)) {
      recommendations.push('Implement Content Security Policy (CSP) headers')
      recommendations.push('Use proper input validation and output encoding')
    }

    if (vulnTypes.has(VulnerabilityType.CSRF)) {
      recommendations.push('Implement CSRF tokens for all state-changing operations')
    }

    if (vulnTypes.has(VulnerabilityType.INSECURE_STORAGE)) {
      recommendations.push('Use secure storage mechanisms for sensitive data')
      recommendations.push('Implement proper data encryption')
    }

    if (vulnTypes.has(VulnerabilityType.WEAK_AUTHENTICATION)) {
      recommendations.push('Implement strong password policies')
      recommendations.push('Enable two-factor authentication')
    }

    if (vulnTypes.has(VulnerabilityType.INSECURE_COMMUNICATION)) {
      recommendations.push('Enable HTTPS for all communications')
      recommendations.push('Implement HTTP Strict Transport Security (HSTS)')
    }

    if (recommendations.length === 0) {
      recommendations.push('Continue regular security monitoring')
      recommendations.push('Keep dependencies up to date')
    }

    return recommendations
  }

  /**
   * Save vulnerability report
   */
  private static saveReport(report: VulnerabilityReport): void {
    this.reports.push(report)

    // Keep only recent reports
    if (this.reports.length > this.MAX_REPORTS) {
      this.reports = this.reports.slice(-this.MAX_REPORTS)
    }

    try {
      localStorage.setItem(this.REPORTS_KEY, JSON.stringify(this.reports))
    } catch (error) {
      console.error('Failed to save vulnerability report:', error)
    }
  }

  /**
   * Load vulnerability reports
   */
  private static loadReports(): void {
    try {
      const stored = localStorage.getItem(this.REPORTS_KEY)
      if (stored) {
        this.reports = JSON.parse(stored)
      }
    } catch (error) {
      console.error('Failed to load vulnerability reports:', error)
      this.reports = []
    }
  }

  /**
   * Get recent vulnerability reports
   */
  static getReports(limit: number = 10): VulnerabilityReport[] {
    return this.reports.slice(-limit).reverse()
  }

  /**
   * Get latest report
   */
  static getLatestReport(): VulnerabilityReport | null {
    return this.reports.length > 0 ? this.reports[this.reports.length - 1] : null
  }

  /**
   * Get vulnerability statistics
   */
  static getVulnerabilityStats(): {
    totalVulnerabilities: number
    criticalCount: number
    highCount: number
    mediumCount: number
    lowCount: number
    averageRiskScore: number
  } {
    const allVulns = this.reports.flatMap(r => r.vulnerabilities)

    return {
      totalVulnerabilities: allVulns.length,
      criticalCount: allVulns.filter(v => v.severity === SecuritySeverity.CRITICAL).length,
      highCount: allVulns.filter(v => v.severity === SecuritySeverity.HIGH).length,
      mediumCount: allVulns.filter(v => v.severity === SecuritySeverity.MEDIUM).length,
      lowCount: allVulns.filter(v => v.severity === SecuritySeverity.LOW).length,
      averageRiskScore: this.reports.length > 0
        ? this.reports.reduce((sum, r) => sum + r.riskScore, 0) / this.reports.length
        : 0
    }
  }
}

// Initialize on module load
if (typeof window !== 'undefined') {
  VulnerabilityScanner.initialize()
}